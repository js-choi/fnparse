<html>
  <head>
    <title>edu.arizona.fnparse API reference (fnparse)</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <!-- TODO: are we using these (from clojure.org)? If so, add the files -->
    <script src="file/view/code_highlighter.js" type="text/javascript"></script>
    <script src="file/view/clojure.js" type="text/javascript"></script>
    <style>.menuWrapper{height: 36px;}</style>
    <!--[if lte IE 6]>
    <link rel="stylesheet" href="http://www.wikispaces.com/_/2009051601/s/internal_ie.css" type="text/css" />
    <![endif]-->
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">fnparse</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <a class="wiki_link" href="index.html">Overview</a><br />
    <a class="wiki_link" href="api-index.html">API Index</a><br />
    <a class="wiki_link" href="#">Namespaces:</a>
    <ul id="left-sidebar-list">
      <li><a href="edu.arizona.fnparse-api.html" class="wiki_link">edu.arizona.fnparse</a></li>
    </ul>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0">Overview</a>
    
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#edu.arizona.fnparse.cat">edu.arizona.fnparse.cat</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/+">+</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;anything&gt;">&lt;anything&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;ascii-alphanumeric&gt;">&lt;ascii-alphanumeric&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;ascii-control&gt;">&lt;ascii-control&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;ascii-digit&gt;">&lt;ascii-digit&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;ascii-letter&gt;">&lt;ascii-letter&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;decimal-digit&gt;">&lt;decimal-digit&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;emptiness&gt;">&lt;emptiness&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;end-of-input&gt;">&lt;end-of-input&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;fetch-location&gt;">&lt;fetch-location&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;fetch-warnings&gt;">&lt;fetch-warnings&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;hexadecimal-digit&gt;">&lt;hexadecimal-digit&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;lowercase-ascii-letter&gt;">&lt;lowercase-ascii-letter&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;nothing&gt;">&lt;nothing&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/&lt;uppercase-ascii-letter&gt;">&lt;uppercase-ascii-letter&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/add-warning">add-warning</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/alter-location">alter-location</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/annotate-error">annotate-error</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/antilit">antilit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/antiset-term">antiset-term</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/antiterm">antiterm</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/antivalidate">antivalidate</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/case-insensitive-lit">case-insensitive-lit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/cat">cat</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/chook">chook</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/circumfix">circumfix</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/combine">combine</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/defmaker">defmaker</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/defmaker-">defmaker-</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/defmaker-macro">defmaker-macro</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/defrule">defrule</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/defrule-">defrule-</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/effects">effects</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/except">except</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/find">find</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/for">for</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/hook">hook</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/label">label</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/lit">lit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/mapcat">mapcat</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/mapsum">mapsum</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/match">match</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/matches-seq">matches-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/not-followed">not-followed</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/opt">opt</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/parser-m">parser-m</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/peek">peek</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/phrase">phrase</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/prefix">prefix</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/prod">prod</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/radix-digit">radix-digit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/radix-label">radix-label</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/rule?">rule?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/set-term">set-term</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/state?">state?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/substitute">substitute</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/substitute-1">substitute-1</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/suffix">suffix</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/suffix-peek">suffix-peek</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/template-sum">template-sum</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/term">term</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/term*">term*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/term-">term-</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/validate">validate</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/vcat">vcat</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/when">when</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.cat/with-error">with-error</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#edu.arizona.fnparse.clojure">edu.arizona.fnparse.clojure</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;comment-char&gt;">&lt;comment-char&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;comment-indicator&gt;">&lt;comment-indicator&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;comment&gt;">&lt;comment&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;derefed&gt;">&lt;derefed&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;discarded&gt;">&lt;discarded&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;form-end&gt;">&lt;form-end&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;form-series&gt;">&lt;form-series&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;indicator&gt;">&lt;indicator&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;non-alphanumeric-symbol-char&gt;">&lt;non-alphanumeric-symbol-char&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;normal-ws-char&gt;">&lt;normal-ws-char&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;ns-separator&gt;">&lt;ns-separator&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;quoted&gt;">&lt;quoted&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;separator&gt;">&lt;separator&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;syntax-quoted&gt;">&lt;syntax-quoted&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;unquote-spliced&gt;">&lt;unquote-spliced&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;unquoted&gt;">&lt;unquoted&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;var-inner&gt;">&lt;var-inner&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;with-meta-inner&gt;">&lt;with-meta-inner&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;ws&gt;">&lt;ws&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/&lt;ws?&gt;">&lt;ws?&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/fetch-referred-namespace">fetch-referred-namespace</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/ns-qualified-keyword-empty-end">ns-qualified-keyword-empty-end</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/ns-qualified-keyword-end-with-slash">ns-qualified-keyword-end-with-slash</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/ns-resolved-keyword-end">ns-resolved-keyword-end</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/number-tail">number-tail</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/padded-lit">padded-lit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/radix-coefficient-tail">radix-coefficient-tail</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/radix-natural-number">radix-natural-number</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure/read-string">read-string</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#edu.arizona.fnparse.clojure-pure">edu.arizona.fnparse.clojure-pure</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.clojure-pure/radix-label">radix-label</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#edu.arizona.fnparse.core">edu.arizona.fnparse.core</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/*format-remainder-limit*">*format-remainder-limit*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/AParseAnswer">AParseAnswer</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/AState">AState</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/apply">apply</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/failure?">failure?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/find">find</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/format-parse-error">format-parse-error</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/match">match</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/matches-seq">matches-seq</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/substitute">substitute</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/substitute-1">substitute-1</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.core/success?">success?</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#edu.arizona.fnparse.hound">edu.arizona.fnparse.hound</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/+">+</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;anything&gt;">&lt;anything&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;ascii-alphanumeric&gt;">&lt;ascii-alphanumeric&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;ascii-control&gt;">&lt;ascii-control&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;ascii-digit&gt;">&lt;ascii-digit&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;ascii-letter&gt;">&lt;ascii-letter&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;decimal-digit&gt;">&lt;decimal-digit&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;emptiness&gt;">&lt;emptiness&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;end-of-input&gt;">&lt;end-of-input&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;fetch-context&gt;">&lt;fetch-context&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;fetch-location&gt;">&lt;fetch-location&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;fetch-warnings&gt;">&lt;fetch-warnings&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;hexadecimal-digit&gt;">&lt;hexadecimal-digit&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;inc-column&gt;">&lt;inc-column&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;inc-line&gt;">&lt;inc-line&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;lowercase-ascii-letter&gt;">&lt;lowercase-ascii-letter&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;nothing&gt;">&lt;nothing&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/&lt;uppercase-ascii-letter&gt;">&lt;uppercase-ascii-letter&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/add-warning">add-warning</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/alter-context">alter-context</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/alter-location">alter-location</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/annotate-error">annotate-error</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/antilit">antilit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/antiset-term">antiset-term</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/antiterm">antiterm</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/antivalidate">antivalidate</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/case-insensitive-lit">case-insensitive-lit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/cat">cat</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/chook">chook</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/circumfix">circumfix</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/combine">combine</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/defmaker">defmaker</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/defmaker-">defmaker-</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/defmaker-macro">defmaker-macro</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/defrule">defrule</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/defrule-">defrule-</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/effects">effects</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/except">except</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/factor=">factor=</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/find">find</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/for">for</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/format-parse-error">format-parse-error</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/hook">hook</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/hooked-rep">hooked-rep</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/label">label</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/lex">lex</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/lit">lit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/make-state">make-state</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/mapcat">mapcat</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/mapsum">mapsum</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/match">match</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/not-followed">not-followed</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/nothing-descriptors">nothing-descriptors</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/opt">opt</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/parser-m">parser-m</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/peek">peek</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/phrase">phrase</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/prefix">prefix</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/prod">prod</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/radix-digit">radix-digit</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/radix-label">radix-label</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/rep">rep</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/rep*">rep*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/rule?">rule?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/separated-rep">separated-rep</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/separated-rep*">separated-rep*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/set-term">set-term</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/state?">state?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/substitute">substitute</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/substitute-1">substitute-1</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/suffix">suffix</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/template-sum">template-sum</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/term">term</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/term*">term*</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/validate">validate</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/vcat">vcat</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/when">when</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.hound/with-error">with-error</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#edu.arizona.fnparse.json">edu.arizona.fnparse.json</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;array-content&gt;">&lt;array-content&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;array-end&gt;">&lt;array-end&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;array-start&gt;">&lt;array-start&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;array&gt;">&lt;array&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;control-char&gt;">&lt;control-char&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;document&gt;">&lt;document&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;escape-char-start&gt;">&lt;escape-char-start&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;escaped-str-char&gt;">&lt;escaped-str-char&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;false&gt;">&lt;false&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;name-separator&gt;">&lt;name-separator&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;normal-str-char&gt;">&lt;normal-str-char&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;null&gt;">&lt;null&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;object-content&gt;">&lt;object-content&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;object-end&gt;">&lt;object-end&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;object-entry&gt;">&lt;object-entry&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;object-start&gt;">&lt;object-start&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;object&gt;">&lt;object&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;str-char&gt;">&lt;str-char&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;str-content&gt;">&lt;str-content&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;str-delimiter&gt;">&lt;str-delimiter&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;str&gt;">&lt;str&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;true&gt;">&lt;true&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;unicode-sequence&gt;">&lt;unicode-sequence&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;value-separator&gt;">&lt;value-separator&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;value&gt;">&lt;value&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.json/&lt;ws?&gt;">&lt;ws?&gt;</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#edu.arizona.fnparse.math">edu.arizona.fnparse.math</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.math/&lt;addition-level&gt;">&lt;addition-level&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.math/&lt;multiplication-level&gt;">&lt;multiplication-level&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.math/&lt;number&gt;">&lt;number&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.math/&lt;parenthesized&gt;">&lt;parenthesized&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.math/&lt;symbol-content&gt;">&lt;symbol-content&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.math/&lt;ws&gt;">&lt;ws&gt;</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#edu.arizona.fnparse.math/ws-suffix">ws-suffix</a>
    </div>
    <br />
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="namespace-name">edu.arizona.fnparse</span></h1>
by <span id="author">Joshua Choi</span><br />
<br />Usage:
<pre>
(ns your-namespace
  (:require <span id="long-name">edu.arizona.fnparse</span>))
</pre><pre>
</pre><h2>Overview</h2>
<pre id="namespace-docstr">[left-recur]: http://en.wikipedia.org/wiki/Left_recursion
[ll-1]: http://en.wikipedia.org/wiki/LL(1)

_FnParse 3_ is a *pair* of libraries that can create
*unambiguous parsers*.

Overview: Would FnParse be useful for you?
==========================================
_FnParse Hound_ and _FnParse Cat_ are two libraries that
can both create *unambiguous parsers*, but of slightly
different varieties.

When does one need parsers? *Any time you need to turn
text into information via a language.* Data is always
stored in "text" of *some* kind, whether it be an English
sentence, a DNA sequence, or an XML file.

FnParse can write [PEGs](http://www.en.wikipedia.org/wiki/PEG),
an easy way to write unambiguous grammars.
This means that FnParse parsers can represent languages
whose sentences always have one meaning. Examples of
ambiguous languages include Clojure, XML, HTML5, YAML,
JSON, Python, Markdown, and most other computer languages.
FnParse can indeed parse data in all those languages above.
I think. :)

How to learn FnParse
====================
TODO

Similarities between FnParse Hound and Cat
==========================================
FnParse Hound and Cat share very similar APIs. In fact, with
a couple of exceptions listed in the next section, their APIs
seem identical.

Both FnParse Hound and Cat create _rules_. Rule are
functions that eat tokens and turn them into data.

*  A _token_ is a unit of text. Tokens are usually characters,
   because that's easiest to do. (You might already have a
   lexer, however, that turns characters into other tokens,
   which FnParse parsers can use too. Just be consistent
   on what kind of tokens a parser can accept.)
*  A rule accepts a _state object_, which contains
   a _sequence of tokens_ and a _context_, as an argument.
*  A rule determines if the tokens are valid or not
   according to its definition; it either _succeeds_ or
   _fails_.
*  When a rule succeeds, it _consumes_ some tokens (zero or more)
   and calculates the data that those tokens represent. This
   new data is called the _product_. The rule then
   returns an object called an _answer_, which contains
   both the product and the new state.
*  When a rule fails, it creates an _error_ that contains
   information on why the tokens were invalid for that rule.
*  Rules consume tokens from the beginning of the sequence.

(FnParse Cat rules and FnParse Hound rules are *not*
the same and are *incompatible* with each other. The
same goes for Cat and Hound states and answers.)

FnParse Cat and Hound both use the same _error_ type: the
`:edu.arizona.fnparse.core/ParseError` type.

Differences between FnParse Hound and Cat
=========================================
Overview with fancy terms
-------------------------
FnParse Hound creates [Parsec]
(http://www.haskell.org/haskellwiki/Parsec)-like,
[LL(1)][ll-1] or near-LL(1) parsers.
FnParse Cat is a [packrat parser](<a href="http://en.wikipedia.org/Packrat">http://en.wikipedia.org/Packrat</a> parser).
*All* other differences stem from these two fundamental ones.

Overview with plainer language
------------------------------
FnParse Hound's parsers try to save as much memory as possible.
In general, as soon as a Hound parser consumes a token, that
token is discarded forever. This means that you can't backtrack
through your tokens if a rule fails. For some languages, you
want this kind of parser, because those languages are designed
to be able to be interpreted by looking at only one token at
a time: a lookahead of one.

FnParse Cat's parsers take up a lot of memory, but they can
quickly parse more complex parsers. In general, when a Cat parser
consumes tokens, it saves the parse result from those tokens
in a cache. This means that there's unlimited backtracking
and lookahead. In addition, Cat parsers support [left
recursion](left-recur), a very useful way of expressing rules.
You want this kind of languages for relatively complex grammars
that require a lot of backtracking.

When should you use which FnParse
---------------------------------
Many computer data languages are LL(1) or near-LL(1). You
should use _FnParse Hound_ for those. Examples include:

*  [Clojure](http://www.clojure.org)
*  [XML](http://www.w3.org/XML)
*  [JSON](http://json.org)
*  [YAML](http://yaml.org)
*  [CSV](http://en.wikipedia.org/wiki/Comma-separated_values)

Many other, more complex computer programming languages
are not LL(1). Some of them involve left recursion.

*  Standard mathematical expressions (like in [Google
   Calculator](http://www.google.com/calculator))
*  [Python](http://www.python.org)
*  [Java](http://www.java.com)
*  Even [Lojban](http://en.wikipedia.org/wiki/Lojban)

Detailed comparison between Hound and Cat
=========================================
You won't understand this chart until you've learned either Hound
or Cat well.

                   | Hound                  | Cat
------------------ | ---------------------- | -------------------
Better for         | Potentially large data | More complex data
Backtracking[^0]   | None by default[^1]    | Unlimited
Caching of results | No[^2]                 | Yes
Greedy repetition  | Yes[^3]                | No[^4]
Right recursion    | Yes                    | Yes
Left recursion     | No                     | Yes
Context alteration | Yes[^5]                | No[^6]

[^0]:
    The differences in backtracking comes from the differences
    between the `+` operator in Hound and Cat.
[^1]:
    Backtracking in Hound rules is possible using the `lex`
    rule-maker, but it should be minimized.
[^2]:
    In fact, it does the opposite: it tries to prevent
    *any* caching of results to reduce memory.
[^3]:
    Greedy repetition in Hound is done by the `rep` function
    and its friends. Of course, it can be always rewritten to use
    right-recursive rules instead.
[^4]:
    In Cat, you want to use left or right recursion instead.
[^5]:
    In Hound, contexts can be altered in-place using the
    `alter-context` rule-maker, but you should usually
    prefer using custom rule-makers with `defmaker` instead,
    which is just as powerful.
[^6]:
    Use custom rule-makers with `defmaker` if your grammar
    is context-sensitive. TODO: Python example
*[XML]: eXtensible Markup Language
*[YAML]: Yet Another Markup Language
*[JSON]: Javascript Object Notation
*[CSV]: Comma-Separated Values</pre>
<br />
<h2>Public Variables and Functions</h2>

<h2 id="namespace-name">edu.arizona.fnparse.cat</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/+">+</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (+)
       (+ &lt;first&gt;)
       (+ &lt;first&gt; &lt;second&gt; &amp; rest-rules)
</pre>
  <pre id="var-docstr">Creates a summed rule.

Adds the given sub-rules together, forming a new rule.
The order of the sub-rules matters.

This is the FnParse *Cat* version of +. Unlike
FnParse Hound's `+` rule-maker, Cat's *does* backtrack.

This means that it searches for the *first successful*
match from its sub-rules, regardless of whether they
consume tokens or not.

Otherwise, if every sub-rule failed, then a failure
is returned with the proper error descriptors.

This is the plus monadic operator of the `parser-m` monad.

Rule Summary
============
* Consumes: Whatever the succeeding sub-rule consumes.
* Description: FnParse Hound rule-maker
* Error: An intelligent combination of the errors
              from all the failed sub-rules.
* Product: The product of the succeeding sub-rule.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;anything&gt;">&lt;anything&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The generic terminal rule that matches any one token.

Rule Summary
============
* Consumes: One token, any type.
* Description: FnParse Hound rule
* Error: "Expected anything."
* Product: The token it consumes.
* Success: If there are any tokens left, i.e.
 not at the end of input.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;ascii-alphanumeric&gt;">&lt;ascii-alphanumeric&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single alphanumeric ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;ascii-control&gt;">&lt;ascii-control&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single ASCII control character,
i.e. a character within Unicode points 0000 and 001F.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;ascii-digit&gt;">&lt;ascii-digit&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single ASCII numeric digit. You may
want to use instead `decimal-digit`, which automatically
converts digits to Integer objects.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;ascii-letter&gt;">&lt;ascii-letter&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single uppercase or lowercase ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;decimal-digit&gt;">&lt;decimal-digit&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single core-10 digit
character token (i.e. \0 through \9).

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching digit's corresponding Integer object, 0 through 9.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;emptiness&gt;">&lt;emptiness&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The general emptiness rule. (Actually just `(prod nil)`).

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule
* Product: `nil`.
* Success: Always.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;end-of-input&gt;">&lt;end-of-input&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The standard end-of-input rule.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule
* Product: `true`.
* Success: If there are no tokens left.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;fetch-location&gt;">&lt;fetch-location&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule that fetches the current state's location.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule
* Product: The current location.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;fetch-warnings&gt;">&lt;fetch-warnings&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule that fetches the current state's warnings.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule
* Product: The current warnings.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;hexadecimal-digit&gt;">&lt;hexadecimal-digit&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single core-16 digit
character token (i.e. \0 through \F).

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching digit's corresponding Integer object, 0 through 15.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;lowercase-ascii-letter&gt;">&lt;lowercase-ascii-letter&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single lowercase ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;nothing&gt;">&lt;nothing&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The general failing rule.

Use `with-error` or `when` in preference to `&lt;nothing&gt;`,
because the first two rule-makers can attach meaningful
error messages.

Is the zero monadic value of the `parser-m` monad.

Rule Summary
============
* Description: FnParse Hound rule
* Error: `"Expected: absolutely nothing"`.
* Success: Never.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/&lt;uppercase-ascii-letter&gt;">&lt;uppercase-ascii-letter&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single uppercase ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/add-warning">add-warning</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (add-warning message)
</pre>
  <pre id="var-docstr">A rule that adds a new warning with the given message.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule-maker
* Product: `nil`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/alter-location">alter-location</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (alter-location f &amp; args)
</pre>
  <pre id="var-docstr">A rule that alters the current location.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule-maker
* Product: The new location.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/annotate-error">annotate-error</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (annotate-error message-fn rule)
</pre>
  <pre id="var-docstr">Creates an error-annotating rule. Whenever
the given `rule` fails, the error is passed
into the `message-fn` function. This can be
useful to add a message with more info to an
error when certain conditions are met.

`message-fn` must return a string when given
the original `ParseError`, which will be added
to the `ParseError`, or `nil` for no message.
(`ParseError`s are maps of type
`:edu.arizona.fnparse.c/ParseError`.
See its documentation for more information.)</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/antilit">antilit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antilit token)
</pre>
  <pre id="var-docstr">Creates a rule of an antiliteral.
A shortcut for `term`.
It automatically adds an appropriate label.

Rule Summary
============
* Consumes: One token, any type (so long as it doesn't equal `token`).
* Description: FnParse Hound rule-maker
* Error: When `(antilit \a) fails, its error
         says, "Expected anything except 'a'."
* Product: The consumed token.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/antiset-term">antiset-term</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antiset-term l tokens)
</pre>
  <pre id="var-docstr">Creates a terminal rule with an antiset.
A shortcut for `(antiterm l (set tokens))`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/antiterm">antiterm</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antiterm l pred)
</pre>
  <pre id="var-docstr">Exactly like term, only uses the complement of the
given predicate instead.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/antivalidate">antivalidate</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antivalidate pred message rule)
</pre>
  <pre id="var-docstr">Exactly like the `validate` function, except that
it uses the complement of `pred` instead.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/case-insensitive-lit">case-insensitive-lit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (case-insensitive-lit token)
</pre>
  <pre id="var-docstr">Creates a case-insensitive rule using Java's
`Character/toLowerCase` and `Character/toUpperCase`
methods. Only works with `Character`-type tokens.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule-maker
* Success: If there is a next token and it's equal to either
            the upper or lowercase of the given `token`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/cat">cat</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (cat &amp; rules)
</pre>
  <pre id="var-docstr">Creates a concatenated rule out of many given `rules`.

Rule Summary
============
* Consumes: All tokens that the `rules` sequentially consume.
* Description: FnParse Hound rule-maker
* Error: The error of whatever sub-rule failed.
* Product: The sequence (not lazy) of all the `rules`'s respective products.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/chook">chook</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (chook product rule)
</pre>
  <pre id="var-docstr">Creates a rule with a constant semantic hook.
A shortcut for the `for` macro. The name
stands for 'constant-hook'. It's exactly like
`hook`, only the product is a constant; its
product is always the given `product` object.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/circumfix">circumfix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (circumfix prefix-rule body-rule suffix-rule)
</pre>
  <pre id="var-docstr">Creates a circumfixed rule. Use when you want to
concatenate three rules, but you don't care about
the first and third rules' products.
Its product is always the body-rule's product.
A shortcut for `(prefix prefix-rule (suffix body-rule suffix-rule))`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/combine">combine</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (combine rule product-fn)
</pre>
  <pre id="var-docstr">Creates a rule combining the given `rule` into the
`product-fn`.

*Use `cat` or `for`* instead of this function.
You *shouldn't have to use this function*
at all, unless you're doing something special.

The product-fn must return a rule when given the
product of the first rule. `combine` is the bind
monadic function of the parser monad.

Below, the rule returned by `(product-fn
state-after-first-rule)` will be referred to as
`second-rule`.

Rule Summary
============
* Consumes: All tokens that `rule` and then `(product-fn
           state-after-first-rule)` consume.
* Description: FnParse Hound rule-maker
* Product: The product of `(product-fn state-after-first-rule)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/defmaker">defmaker</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defmaker fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Creates a rule-making function. Use this instead of
`clojure.core/defn` whenever you make a rule-making
function. (It does other stuff like memoization and
and stuff.) Also see `defmaker-` and `defmaker-macro`.

Arguments
=========
`defmaker` requires exactly the same arguments as
`clojure.core/defn`. Particularly important is being
able to give metadata easily.

Metadata options
================
`defmaker` accepts all special metadata options that
`defrule` does; see `defrule` for more information.
There is also a `:no-memoize?` option
that does something special, detailed below.

Memoization
===========
`defmaker` rule-makers *memoize by default*. This means
that they save the arguments they receive and their
corresponding results in a cache, and search the cache
every time they are called for equal arguments. See
`clojure.k/memoize` for more information.

95% of the time, you won't have to worry about the warning below.

A warning: memoization uses *Clojure equality*. This
means that giving vector arguments must always return the
same rule as giving list arguments, because vectors can
be equal to lists. If your function must return a different
rule when given `[1 2 3]` versus `'(1 2 3)`, then you should
give `{:no-memoize? true}` in your metadata.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/defmaker-">defmaker-</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defmaker- fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Like `defmaker`, but also makes the var private.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/defmaker-macro">defmaker-macro</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defmaker-macro fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Like `defmaker`, but makes a macro rule-maker
instead of a function rule-maker.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/defrule">defrule</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defrule rule-name form)
       (defrule rule-name doc-string form)
       (defrule rule-name doc-string meta-opts form)
</pre>
  <pre id="var-docstr">Defines a rule var. You really should use this instead of `def`
whenever you define rules, because:
1. It gives you cool shortcuts to write rule-related documentation.
2. It allows you to use not-yet defined rules in mutually
   recursive rules.

Metadata documentation options
==============================
The `meta-opts` parameter expects a map argument,
and makes it the new var's metadata. Giving certain
options in the metadata also does appends certain
things to the rule's `doc-string`.

*  `:succeeds` expects a short description on when
   the rule succeeds.
*  `:product` expects a short description on what
   products the rule gives when it succeeds.
*  `:consumes` expects a short description on how
   many and what kinds of tokens the rule consumes
   when it succeeds.
*  `:error` expects a short description on the
   error that the rule gives when it fails.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/defrule-">defrule-</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defrule- fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Like `defrule`, but also makes the var private.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/effects">effects</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (effects f &amp; args)
</pre>
  <pre id="var-docstr">Creates a side-effect rule. Applies the given
arguments to the given function. You may prefer `prod`.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker
* Product: The result of `(apply f args)`.
* Success: Always.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/except">except</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (except l &lt;minuend&gt; &amp; subtrahends)
</pre>
  <pre id="var-docstr">Creates a subtracted rule. Matches using
the given minuend rule, but only when the
subtrahend rule does not also match. You
must provide a custom `l`.

`message-fn`, if given, creates a detailed error
message when the `subtrahend` succeeds. `message-fn`
should be a function that takes one argument: `subtrahend`'s
product, and returns a string.

Rule Summary
============
* Consumes: Whatever `minuend` consumes.
* Description: FnParse Hound rule-maker
* Error: Uses the `l` you provide.
* Product: `minuend`'s product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/find">find</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (find state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Finds all occurrences of a rule in a sequence of tokens.
Returns a lazy sequence of the rule's products at each
occurence. The occurences do not overlap.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/for">for</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (for l steps product-expr)
       (for steps product-expr)
</pre>
  <pre id="var-docstr">Creates a rule comprehension, very much like
`clojure.core/for`. If it succeeds or fails and
also how many tokens it consumes is similar to `cat`.
How the final product is calculated is similar to `hook`.

If you want to know, this macro is equivalent to the
`clojure.contrib.monads/domonad` form of the `parser-m` monad.

Arguments
=========
*   `l`: An optional label string. See the
    `label` function for more info.
*   `steps`: A binding vector containing *binding-form/
    rule pairs* optionally followed by *modifiers*.
    The given rules in each pair are concatenated
    together one after another to create
    the new rule. Each binding-form is bound
    to the product of its corresponding rule.
    The rule expressions can refer to any
    symbol bound to in a previous pair.
    The only current recommended modifier
    is `:let`, which works like how it does it
    `clojure.core/for`.
*   `product-expr`: The final product of the new rule.
    Only is reached after every sub-rule
    succeeds. The expression can refer
    to any symbol bound to in the `steps`.

Rule Summary
============
* Consumes: All tokens that each step consecutively consumes.
* Description: FnParse Hound macro rule-maker
* Error: Whatever error the failed rule returns.
* Product: Whatever is calculated by `product-expr`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/hook">hook</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (hook semantic-hook rule)
</pre>
  <pre id="var-docstr">Creates a rule with a semantic hook.
A shortcut for the `for` macro.

Rule Summary
============
* Consumes: Whatever `rule` consumes.
* Description: FnParse Hound rule-maker
* Product: `(semantic-hook product-from-rule)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/label">label</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (label l rule)
</pre>
  <pre id="var-docstr">Creates a labelled rule.

Labels the given rule with the given string, returning
a new rule. The given label will appear in the descriptors
of any parse errors that expected the given rule to
succeed.

Personally, I label rules with articles like "a" or "an".
For instance, I'd label a rule representing Clojure
vectors "a vector".

You don't have to understand the details, but...
If `rule` consumed *no* tokens, then all error labels
from `rule`'s result are overrided with the
given `l`. Otherwise, the old labels are
untouched, as they contain information from
further down the input.

Rule Summary
============
* Consumes: Whatever `rule` consumes.
* Description: FnParse Hound rule-maker
* Error: Smartly determines the appropriate error message.
* Product: `rule`'s product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/lit">lit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (lit token)
</pre>
  <pre id="var-docstr">Creates a rule of a literal. A shortcut for
`(term (partial = token))`. It automatically adds an
appropriate label.

Rule Summary
============
* Consumes: One token, equal to the given `token`.
* Description: FnParse Hound rule-maker
* Error: When `(lit \a) fails, its error says, "Expected 'a'."
* Product: Always the consumed `token`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/mapcat">mapcat</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (mapcat f &amp; token-colls)
</pre>
  <pre id="var-docstr">Creates a rule that is the result of
applying `cat` to the result of applying map
to `f` and `token-colls`.
Use the `phrase` function instead of this
function when `f` is just `lit`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/mapsum">mapsum</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (mapsum f &amp; token-colls)
</pre>
  <pre id="var-docstr">Creates a rule that is the result of applying `+` to the
result of applying map to `f` and `token-colls`.
Use the `set-term` function instead of this
function when `f` is just `lit`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/match">match</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (match state rule &amp; {:keys #{failure-fn success-fn}, :or {success-fn print-success, failure-fn print-failure}})
</pre>
  <pre id="var-docstr">The general matching function of FnParse. Attempts to
match the given rule to at least the beginning of the given input.

*   `rule`: The rule to match with.
*   `state`: The initial state.
*   `success-fn`: An optional function called when the rule
    matches the input.
    `(complete-fn final-product final-remainder)` is called.
*   `failure-fn`: An optional function called when the rule does not
    match the input. `(failure-fn final-error)` is called,
    where `final-error` is an object of type
    `:edu.arizona.fnparse.ParseError`.
  
If `success-fn` and `failure-fn` aren't included, then
`match` will print out a report of the parsing result.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/matches-seq">matches-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (matches-seq state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Finds all *consecutive* occurrences of a rule in a
sequence of tokens.
Returns a lazy sequence of the rule's products at each
occurence. The occurrences must come one after another,
or else the last element of the sequence will be a ParseError.
The occurrences also do not overlap.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/not-followed">not-followed</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (not-followed l &lt;base&gt; &amp; following-rules)
</pre>
  <pre id="var-docstr">See also `except`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/opt">opt</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (opt rule)
</pre>
  <pre id="var-docstr">Creates an optional rule. It is equivalent to `(+ rule emptiness)`.

Rule Summary
============
* Consumes: Either whatever `rule` consumes (if it succeeds) or no tokens.
* Description: FnParse Hound rule-maker
* Product: Either `rule`'s product (if it succeeds) or `nil` if it fails.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/parser-m">parser-m</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The monad that FnParse Cat uses.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/peek">peek</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (peek rule)
</pre>
  <pre id="var-docstr">Creates a lookahead rule. Checks if the given
`rule` succeeds, but doesn't actually consume
any tokens.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/phrase">phrase</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (phrase tokens)
</pre>
  <pre id="var-docstr">Creates a phrase rule, which succeeds
only when the next few tokens all
consecutively match the given tokens.
(Actually, it's just `(mapcat lit tokens)`.)</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/prefix">prefix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (prefix prefix-rule body-rule)
</pre>
  <pre id="var-docstr">Creates a prefixed rule. Use when you want to
concatenate two rules, but you don't care about
the first rule's product.
Its product is always the body-rule's product.
A shortcut for `(for [_ prefix-rule, content body-rule] content)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/prod">prod</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (prod product)
</pre>
  <pre id="var-docstr">Creates a rule that always returns the given `product`.

Use the `:let` modifier in preference to this function
when you use this inside rule comprehensions from the
`for` macro.

Is the result monadic function of the `parser-m` monad.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker
* Product: The given `product`.
* Success: Always.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/radix-digit">radix-digit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (radix-digit core)
</pre>
  <pre id="var-docstr">Returns a rule that accepts one digit character
token in the number system with the given `core`.
For instance, `(radix-digit 12)` is a rule
of a single duodecimal digit.

Digits past 9 are case-insensitive letters:
11, for instance, is \b or \B. cores above
36 are accepted, but there's no way to use
digits beyond \Z (which corresponds to 36).

The rules `&lt;decimal-digit&gt;` and
`&lt;hexadecimal-digit&gt;` are already provided.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule-maker
* Product: The digit's corresponding integer.
* Success: If the next token is a digit
  character in the given `core`'s number
  system.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/radix-label">radix-label</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (radix-label core)
</pre>
  <pre id="var-docstr">The function used by radix-digit to smartly
create digit labels for the given `core`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/rule?">rule?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (rule? obj)
</pre>
  <pre id="var-docstr">Tests if the given object is a Hound Rule, or a var containing a Hound Rule.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/set-term">set-term</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (set-term l tokens)
</pre>
  <pre id="var-docstr">Creates a terminal rule with a set.
A shortcut for `(term l (set tokens))`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/state?">state?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (state? obj)
</pre>
  <pre id="var-docstr">Tests if the given object is a Hound State.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/substitute">substitute</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (substitute state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Substitutes all occurences of a rule in a sequence of tokens
with their respective products. Returns a lazy sequence of
tokens and products.

`flatten?` is a boolean. If it is true, then the substituting
products will be flattened into the input sequence; in that
case the products must always be Seqables.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/substitute-1">substitute-1</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (substitute-1 state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Substitutes the first occurence of a rule in a sequence of
tokens with its respective product. Returns a lazy sequence
of tokens and products.

See `substitute`'s docs for information on `flatten?`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/suffix">suffix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (suffix body-rule suffix-rule)
</pre>
  <pre id="var-docstr">Creates a suffixed rule. Use when you want to
concatenate two rules, but you don't care about
the second rule's product.
Its product is always the body-rule's product.
A shortcut for `(for [content body-rule, _ suffix-rule] content)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/suffix-peek">suffix-peek</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (suffix-peek &lt;main&gt; &lt;following&gt;)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/template-sum">template-sum</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (template-sum argv expr &amp; values)
</pre>
  <pre id="var-docstr">Creates a summed rule using a template.
Acts very similarly to `clojure.template/do-template`,
but instead sums each rule together.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/term">term</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (term l predicate)
</pre>
  <pre id="var-docstr">Creates a terminal rule.

The new rule either consumes one token or fails.
It must have a `l` that describes it
and a `predicate` to test if the token it consumes is
valid.

Do you really need to use `term`?
=================================
* If you just want to make sure that the consumed
  token equals something, use `lit` instead.
* If you just want to make sure that the consumed
  token equals one of a bunch of things, use `term`
  on a set of tokens, or `set-term` on a sequence of
  tokens.
* If you want to use the complement of the predicate,
  use `antiterm`.
* If you don't care about what token is consumed,
  just as long as a token is consumed, use `-anything-`.
* If you want a terminal rule, but you want the result
  of the predicate to be the rule's product instead of
  the token itself, use `term*`. This is useful if
  you have a map of tokens and their products (e.g.
  string escape sequences).

Rule Summary
============
* Consumes: One token, any type that fulfills `pred`.
* Description: FnParse Hound rule-maker
* Error: When `(term "number" num?)` fails,
         its error is "Expected number."
* Product: The consumed token itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/term*">term*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (term* l f)
</pre>
  <pre id="var-docstr">Exactly like `term`, only its product is the result of
`(f token)` rather than `token`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/term-">term-</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (term- pred-product? l f)
</pre>
  <pre id="var-docstr">All terminal Cat rules, including `term` and
`term*`, are based on this function.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/validate">validate</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (validate pred message rule)
</pre>
  <pre id="var-docstr">Creates a validating rule.

A convenience function. Returns a new rule that
acts like the given `rule`, but also validates
`rule`'s products with the given predicate.
Basically just a shortcut for `for` and `when`.

Rule Summary
============
* Consumes: What `rule` consumes.
* Description: FnParse Hound rule-maker
* Product: `rule`'s product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/vcat">vcat</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (vcat &amp; subrules)
</pre>
  <pre id="var-docstr">Exactly like cat, only applies `vec` to its product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/when">when</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (when valid? message)
</pre>
  <pre id="var-docstr">Creates a maybe-failing rule
an either succeeding or a failing rule
depending on if `valid?` is logical true. If
`valid?`, then the rule always succeeds and acts
like `(prod valid?)`. If not `valid?`, then the
rule always fails and acts like `(with-error message)`.

Examples
========
This function is very useful for when you want
to validate a certain rule.

  (for [value &lt;number&gt;
          _ (when (&lt; odd 10)
              "number must be less than ten")]
      value)

The rule given above succeeds only when `&lt;number&gt;`
matches and `&lt;number&gt;`'s product is less than 10.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker
* Product: The value of `valid?`.
* Success: If `valid?` is a true value.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.cat/with-error">with-error</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (with-error message)
</pre>
  <pre id="var-docstr">Creates an always-failing rule with the given
message. Use this in preference to `&lt;nothing&gt;`.

Rule Summary
============
* Description: FnParse Hound rule-maker
* Error: An error with the given `message`.
* Success: Never.</pre>
  
</div>
<h2 id="namespace-name">edu.arizona.fnparse.clojure</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;comment-char&gt;">&lt;comment-char&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a character inside a line comment, i.e. any non-break character.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;comment-indicator&gt;">&lt;comment-indicator&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">There are two line comment indicators, `;` and `#!`.
This rule consumes either of them.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;comment&gt;">&lt;comment&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a line comment.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;derefed&gt;">&lt;derefed&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;discarded&gt;">&lt;discarded&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a discarded form (prefixed by `#_`), which counts as whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;form-end&gt;">&lt;form-end&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Peeks and checks for a separator or the end of input.

Rule Summary
============
* Consumes: No characters.
* Description: FnParse Hound rule</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;form-series&gt;">&lt;form-series&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;indicator&gt;">&lt;indicator&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a Clojure indicator character.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;non-alphanumeric-symbol-char&gt;">&lt;non-alphanumeric-symbol-char&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a non-alphanumeric character allowed in Clojure symbols.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;normal-ws-char&gt;">&lt;normal-ws-char&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a normal whitespace character such as space or newline.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;ns-separator&gt;">&lt;ns-separator&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a forward slash: the separator of namespaces.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;quoted&gt;">&lt;quoted&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;separator&gt;">&lt;separator&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a separator of Clojure forms: whitespace or an indicator.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;syntax-quoted&gt;">&lt;syntax-quoted&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;unquote-spliced&gt;">&lt;unquote-spliced&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;unquoted&gt;">&lt;unquoted&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;var-inner&gt;">&lt;var-inner&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;with-meta-inner&gt;">&lt;with-meta-inner&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;ws&gt;">&lt;ws&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The general whitespace rule: spaces, line comments, and discarded forms.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/&lt;ws?&gt;">&lt;ws?&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/fetch-referred-namespace">fetch-referred-namespace</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (fetch-referred-namespace context namespace-alias)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/ns-qualified-keyword-empty-end">ns-qualified-keyword-empty-end</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (ns-qualified-keyword-empty-end pre-slash)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/ns-qualified-keyword-end-with-slash">ns-qualified-keyword-end-with-slash</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (ns-qualified-keyword-end-with-slash pre-slash)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/ns-resolved-keyword-end">ns-resolved-keyword-end</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (ns-resolved-keyword-end pre-slash)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/number-tail">number-tail</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (number-tail core)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/padded-lit">padded-lit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (padded-lit token)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/radix-coefficient-tail">radix-coefficient-tail</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (radix-coefficient-tail core)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/radix-natural-number">radix-natural-number</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (radix-natural-number core)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure/read-string">read-string</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (read-string input &amp; opts)
</pre>
  <pre id="var-docstr">Reads one object from the given string. Also can
take the options below. If the reading is successful,
the resulting object is returned. Otherwise, a Java
Exception is thrown.
ns-name: A string. The name of the namespace to
         interpret double-coloned keywords in.
         Defaults to (name *ns*).
ns-aliases: A map of strings to strings. Keys are
            namespace aliases, and vals are
            corresponding namespace names. Defaults
            to (ns-aliases *ns*).
reader-eval?: A boolean. If logical true, allows
              ReaderEval forms (i.e. #=(...)),
              which can create security holes.
              Defaults to *read-eval*.</pre>
  
</div>
<h2 id="namespace-name">edu.arizona.fnparse.clojure-pure</h2>
<pre id="namespace-docstr">This is a proof-of-concept Clojure parser implemented in *pure Clojure*.
It, and all functions it uses in its referred libraries, except
`clojure.core`, use *no* direct Java calls (with the exception
of the Exception thrown in the final read-string function.)</pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.clojure-pure/radix-label">radix-label</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (radix-label core)
</pre>
  <pre id="var-docstr">The function used by radix-digit to smartly
create digit labels for the given `core`.</pre>
  
</div>
<h2 id="namespace-name">edu.arizona.fnparse.core</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/*format-remainder-limit*">*format-remainder-limit*</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The limit at which `format-remainder`will cut off lengthy
remainders at. Must be a positive integer.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/AParseAnswer">AParseAnswer</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The protocol of FnParse Answers: what
FnParse rules must return. Answers must
contain a Resulti.e. a Success or Failure.
This protocol is necessary for the parse
function.
  FnParse Cat rules return Successes or
Failures, which are their own Answers.
  FnParse Hound rules return Replies, which
contain Results.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/AState">AState</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The protocol of FnParse states, which must
be able to return a position.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/apply">apply</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (apply rule state)
</pre>
  <pre id="var-docstr">Applies the given rule to the given state.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/failure?">failure?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (failure? result)
</pre>
  <pre id="var-docstr">Is the given result a Failure?</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/find">find</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (find state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Finds all occurrences of a rule in a sequence of tokens.
Returns a lazy sequence of the rule's products at each
occurence. The occurences do not overlap.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/format-parse-error">format-parse-error</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (format-parse-error error)
</pre>
  <pre id="var-docstr">Returns a formatted string from the given error.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/match">match</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (match state rule &amp; {:keys #{failure-fn success-fn}, :or {success-fn print-success, failure-fn print-failure}})
</pre>
  <pre id="var-docstr">The general matching function of FnParse. Attempts to
match the given rule to at least the beginning of the given input.

*   `rule`: The rule to match with.
*   `state`: The initial state.
*   `success-fn`: An optional function called when the rule
    matches the input.
    `(complete-fn final-product final-remainder)` is called.
*   `failure-fn`: An optional function called when the rule does not
    match the input. `(failure-fn final-error)` is called,
    where `final-error` is an object of type
    `:edu.arizona.fnparse.ParseError`.
  
If `success-fn` and `failure-fn` aren't included, then
`match` will print out a report of the parsing result.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/matches-seq">matches-seq</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (matches-seq state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Finds all *consecutive* occurrences of a rule in a
sequence of tokens.
Returns a lazy sequence of the rule's products at each
occurence. The occurrences must come one after another,
or else the last element of the sequence will be a ParseError.
The occurrences also do not overlap.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/substitute">substitute</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (substitute state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Substitutes all occurences of a rule in a sequence of tokens
with their respective products. Returns a lazy sequence of
tokens and products.

`flatten?` is a boolean. If it is true, then the substituting
products will be flattened into the input sequence; in that
case the products must always be Seqables.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/substitute-1">substitute-1</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (substitute-1 state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Substitutes the first occurence of a rule in a sequence of
tokens with its respective product. Returns a lazy sequence
of tokens and products.

See `substitute`'s docs for information on `flatten?`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.core/success?">success?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (success? result)
</pre>
  <pre id="var-docstr">Is the given result is a Success?</pre>
  
</div>
<h2 id="namespace-name">edu.arizona.fnparse.hound</h2>
<pre id="namespace-docstr">This is *FnParse Hound*, which can create unambiguous
LL(1) or LL(n) parsers.</pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/+">+</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (+ &amp; rules)
</pre>
  <pre id="var-docstr">Creates a summed rule.

Adds the given sub-rules together, forming a new rule.
The order of the sub-rules matters.

This is the FnParse *Hound* version of +. It does *not*
backtrack. This is the heart of the LL(1) properties of
FnParse Hound.

This means that it *first* searches for a successful parse from its
sub-rules that *consumed any tokens*. The first such success is
*immediately returned*.

If all sub-rules that consumed tokens failed, then
the first successful parse that *didn't* consume any
tokens is returned.

Otherwise, if every sub-rule failed, then a failure
is returned with the proper error descriptors.

This is the plus monadic operator of the `parser-m` monad.

Rule Summary
============
* Consumes: Whatever the succeeding sub-rule consumes.
* Description: FnParse Hound rule-maker
* Error: An intelligent combination of the errors
              from all the failed sub-rules.
* Product: The product of the succeeding sub-rule.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;anything&gt;">&lt;anything&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The generic terminal rule that matches any one token.

Rule Summary
============
* Consumes: One token, any type.
* Description: FnParse Hound rule
* Error: "Expected anything."
* Product: The token it consumes.
* Success: If there are any tokens left, i.e.
 not at the end of input.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;ascii-alphanumeric&gt;">&lt;ascii-alphanumeric&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single alphanumeric ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;ascii-control&gt;">&lt;ascii-control&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single ASCII control character,
i.e. a character within Unicode points 0000 and 001F.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;ascii-digit&gt;">&lt;ascii-digit&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single ASCII numeric digit. You may
want to use instead `decimal-digit`, which automatically
converts digits to Integer objects.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;ascii-letter&gt;">&lt;ascii-letter&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single uppercase or lowercase ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;decimal-digit&gt;">&lt;decimal-digit&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single core-10 digit
character token (i.e. \0 through \9).

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching digit's corresponding Integer object, 0 through 9.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;emptiness&gt;">&lt;emptiness&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The general emptiness rule. (Actually just `(prod nil)`).

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule
* Product: `nil`.
* Success: Always.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;end-of-input&gt;">&lt;end-of-input&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The standard end-of-input rule.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule
* Product: `true`.
* Success: If there are no tokens left.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;fetch-context&gt;">&lt;fetch-context&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule that fetches the current context.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule
* Product: The current context.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;fetch-location&gt;">&lt;fetch-location&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule that fetches the current state's location.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule
* Product: The current location.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;fetch-warnings&gt;">&lt;fetch-warnings&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule that fetches the current state's warnings.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule
* Product: The current warnings.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;hexadecimal-digit&gt;">&lt;hexadecimal-digit&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single core-16 digit
character token (i.e. \0 through \F).

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching digit's corresponding Integer object, 0 through 15.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;inc-column&gt;">&lt;inc-column&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A literal rule that also increments
the column of a state's location. The `:location`
of any state that this rule receives must extend
the `edu.arizona.fnparse.core.ALineAndColumnLocation` protocol.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;inc-line&gt;">&lt;inc-line&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A literal rule that also increments
the line of a state's StandardLocation and resets its
column to zero. The `:location`
of any state that this rule receives must extend
the `edu.arizona.fnparse.core.ALineAndColumnLocation` protocol.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;lowercase-ascii-letter&gt;">&lt;lowercase-ascii-letter&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single lowercase ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;nothing&gt;">&lt;nothing&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The general failing rule.

Use `with-error` or `when` in preference to `&lt;nothing&gt;`,
because the first two rule-makers can attach meaningful
error messages.

Is the zero monadic value of the `parser-m` monad.

Rule Summary
============
* Description: FnParse Hound rule
* Error: `"Expected: absolutely nothing"`.
* Success: Never.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/&lt;uppercase-ascii-letter&gt;">&lt;uppercase-ascii-letter&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A rule matching a single uppercase ASCII letter.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: The matching character itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/add-warning">add-warning</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (add-warning message)
</pre>
  <pre id="var-docstr">A rule that adds a new warning with the given message.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule-maker
* Product: `nil`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/alter-context">alter-context</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (alter-context f &amp; args)
</pre>
  <pre id="var-docstr">A rule that alters the current context.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule-maker
* Product: The new context.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/alter-location">alter-location</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (alter-location f &amp; args)
</pre>
  <pre id="var-docstr">A rule that alters the current location.

Rule Summary
============
* Consumes: Zero tokens.
* Description: FnParse Hound rule-maker
* Product: The new location.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/annotate-error">annotate-error</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (annotate-error message-fn rule)
</pre>
  <pre id="var-docstr">Creates an error-annotating rule. Whenever
the given `rule` fails, the error is passed
into the `message-fn` function. This can be
useful to add a message with more info to an
error when certain conditions are met.

`message-fn` must return a string when given
the original `ParseError`, which will be added
to the `ParseError`, or `nil` for no message.
(`ParseError`s are maps of type
`:edu.arizona.fnparse.c/ParseError`.
See its documentation for more information.)</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/antilit">antilit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antilit token)
</pre>
  <pre id="var-docstr">Creates a rule of an antiliteral.
A shortcut for `term`.
It automatically adds an appropriate label.

Rule Summary
============
* Consumes: One token, any type (so long as it doesn't equal `token`).
* Description: FnParse Hound rule-maker
* Error: When `(antilit \a) fails, its error
         says, "Expected anything except 'a'."
* Product: The consumed token.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/antiset-term">antiset-term</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antiset-term l tokens)
</pre>
  <pre id="var-docstr">Creates a terminal rule with an antiset.
A shortcut for `(antiterm l (set tokens))`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/antiterm">antiterm</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antiterm l pred)
</pre>
  <pre id="var-docstr">Exactly like term, only uses the complement of the
given predicate instead.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/antivalidate">antivalidate</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (antivalidate pred message rule)
</pre>
  <pre id="var-docstr">Exactly like the `validate` function, except that
it uses the complement of `pred` instead.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/case-insensitive-lit">case-insensitive-lit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (case-insensitive-lit token)
</pre>
  <pre id="var-docstr">Creates a case-insensitive rule using Java's
`Character/toLowerCase` and `Character/toUpperCase`
methods. Only works with `Character`-type tokens.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule-maker
* Success: If there is a next token and it's equal to either
            the upper or lowercase of the given `token`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/cat">cat</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (cat &amp; rules)
</pre>
  <pre id="var-docstr">Creates a concatenated rule out of many given `rules`.

Rule Summary
============
* Consumes: All tokens that the `rules` sequentially consume.
* Description: FnParse Hound rule-maker
* Error: The error of whatever sub-rule failed.
* Product: The sequence (not lazy) of all the `rules`'s respective products.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/chook">chook</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (chook product rule)
</pre>
  <pre id="var-docstr">Creates a rule with a constant semantic hook.
A shortcut for the `for` macro. The name
stands for 'constant-hook'. It's exactly like
`hook`, only the product is a constant; its
product is always the given `product` object.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/circumfix">circumfix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (circumfix prefix-rule body-rule suffix-rule)
</pre>
  <pre id="var-docstr">Creates a circumfixed rule. Use when you want to
concatenate three rules, but you don't care about
the first and third rules' products.
Its product is always the body-rule's product.
A shortcut for `(prefix prefix-rule (suffix body-rule suffix-rule))`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/combine">combine</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (combine rule product-fn)
</pre>
  <pre id="var-docstr">Creates a rule combining the given `rule` into the
`product-fn`.

*Use `cat` or `for`* instead of this function.
You *shouldn't have to use this function*
at all, unless you're doing something special.

The product-fn must return a rule when given the
product of the first rule. `combine` is the bind
monadic function of the parser monad.

Below, the rule returned by `(product-fn
state-after-first-rule)` will be referred to as
`second-rule`.

Rule Summary
============
* Consumes: All tokens that `rule` and then `(product-fn
           state-after-first-rule)` consume.
* Description: FnParse Hound rule-maker
* Product: The product of `(product-fn state-after-first-rule)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/defmaker">defmaker</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defmaker fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Creates a rule-making function. Use this instead of
`clojure.core/defn` whenever you make a rule-making
function. (It does other stuff like memoization and
and stuff.) Also see `defmaker-` and `defmaker-macro`.

Arguments
=========
`defmaker` requires exactly the same arguments as
`clojure.core/defn`. Particularly important is being
able to give metadata easily.

Metadata options
================
`defmaker` accepts all special metadata options that
`defrule` does; see `defrule` for more information.
There is also a `:no-memoize?` option
that does something special, detailed below.

Memoization
===========
`defmaker` rule-makers *memoize by default*. This means
that they save the arguments they receive and their
corresponding results in a cache, and search the cache
every time they are called for equal arguments. See
`clojure.k/memoize` for more information.

95% of the time, you won't have to worry about the warning below.

A warning: memoization uses *Clojure equality*. This
means that giving vector arguments must always return the
same rule as giving list arguments, because vectors can
be equal to lists. If your function must return a different
rule when given `[1 2 3]` versus `'(1 2 3)`, then you should
give `{:no-memoize? true}` in your metadata.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/defmaker-">defmaker-</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defmaker- fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Like `defmaker`, but also makes the var private.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/defmaker-macro">defmaker-macro</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defmaker-macro fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Like `defmaker`, but makes a macro rule-maker
instead of a function rule-maker.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/defrule">defrule</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defrule rule-name form)
       (defrule rule-name doc-string form)
       (defrule rule-name doc-string meta-opts form)
</pre>
  <pre id="var-docstr">Defines a rule var. You really should use this instead of `def`
whenever you define rules, because:
1. It gives you cool shortcuts to write rule-related documentation.
2. It allows you to use not-yet defined rules in mutually
   recursive rules.

Metadata documentation options
==============================
The `meta-opts` parameter expects a map argument,
and makes it the new var's metadata. Giving certain
options in the metadata also does appends certain
things to the rule's `doc-string`.

*  `:succeeds` expects a short description on when
   the rule succeeds.
*  `:product` expects a short description on what
   products the rule gives when it succeeds.
*  `:consumes` expects a short description on how
   many and what kinds of tokens the rule consumes
   when it succeeds.
*  `:error` expects a short description on the
   error that the rule gives when it fails.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/defrule-">defrule-</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (defrule- fn-name &amp; forms)
</pre>
  <pre id="var-docstr">Like `defrule`, but also makes the var private.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/effects">effects</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (effects f &amp; args)
</pre>
  <pre id="var-docstr">Creates a side-effect rule. Applies the given
arguments to the given function. You may prefer `prod`.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker
* Product: Always `nil`.
* Success: Always.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/except">except</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (except l &lt;minuend&gt; &amp; subtrahends)
</pre>
  <pre id="var-docstr">Creates a subtracted rule. Matches using
the given minuend rule, but only when the
subtrahend rule does not also match. You
must provide a custom `l`.

`message-fn`, if given, creates a detailed error
message when the `subtrahend` succeeds. `message-fn`
should be a function that takes one argument: `subtrahend`'s
product, and returns a string.

Rule Summary
============
* Consumes: Whatever `minuend` consumes.
* Description: FnParse Hound rule-maker
* Error: Uses the `l` you provide.
* Product: `minuend`'s product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/factor=">factor=</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (factor= n rule)
</pre>
  <pre id="var-docstr">Creates a non-greedy repetition rule.
Concatenates the given `rule` to itself `n` times.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/find">find</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (find state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Finds all occurrences of a rule in a sequence of tokens.
Returns a lazy sequence of the rule's products at each
occurence. The occurences do not overlap.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/for">for</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (for l steps product-expr)
       (for steps product-expr)
</pre>
  <pre id="var-docstr">Creates a rule comprehension, very much like
`clojure.core/for`. If it succeeds or fails and
also how many tokens it consumes is similar to `cat`.
How the final product is calculated is similar to `hook`.

If you want to know, this macro is equivalent to the
`clojure.contrib.monads/domonad` form of the `parser-m` monad.

Arguments
=========
*   `l`: An optional label string. See the
    `label` function for more info.
*   `steps`: A binding vector containing *binding-form/
    rule pairs* optionally followed by *modifiers*.
    The given rules in each pair are concatenated
    together one after another to create
    the new rule. Each binding-form is bound
    to the product of its corresponding rule.
    The rule expressions can refer to any
    symbol bound to in a previous pair.
    The only current recommended modifier
    is `:let`, which works like how it does it
    `clojure.core/for`.
*   `product-expr`: The final product of the new rule.
    Only is reached after every sub-rule
    succeeds. The expression can refer
    to any symbol bound to in the `steps`.

Rule Summary
============
* Consumes: All tokens that each step consecutively consumes.
* Description: FnParse Hound macro rule-maker
* Error: Whatever error the failed rule returns.
* Product: Whatever is calculated by `product-expr`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/format-parse-error">format-parse-error</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (format-parse-error error)
</pre>
  <pre id="var-docstr">Returns a formatted string from the given error.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/hook">hook</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (hook semantic-hook rule)
</pre>
  <pre id="var-docstr">Creates a rule with a semantic hook.
A shortcut for the `for` macro.

Rule Summary
============
* Consumes: Whatever `rule` consumes.
* Description: FnParse Hound rule-maker
* Product: `(semantic-hook product-from-rule)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/hooked-rep">hooked-rep</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (hooked-rep f initial-product rule)
</pre>
  <pre id="var-docstr">A `reduce`-like version of `rep`. See `rep` for more info.

`f` should be a function of two arguments. The
product is the result of applying `f` first to
`initial-product` and the product of `rule`'s
first match, then applying `f` to that result and
the product of `rule`'s second match, and so on.

Why would you use this instead of `(-&gt;&gt; rule rep
(hook #(reduce f initial-product %)))`? Because
this saves memory. Using `rep` and `hook` instead
forces the entire repetition's product to be in
memory at the start, which may be prohibitive for
potentially large repititions.

*Warning!* Do not use this with any rules that
possibly may succeed without consuming any tokens.
An error will be thrown, because it would otherwise
create an infinite loop.

Rule Summary
============
* Consumes: As many tokens as rule can consecutively consume.
* Description: FnParse Hound rule-maker
* Product: `(reduce f initial-product seq-of-consecutive-rule-products)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/label">label</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (label l rule)
</pre>
  <pre id="var-docstr">Creates a labelled rule.

Labels the given rule with the given string, returning
a new rule. The given label will appear in the descriptors
of any parse errors that expected the given rule to
succeed.

Personally, I label rules with articles like "a" or "an".
For instance, I'd label a rule representing Clojure
vectors "a vector".

You don't have to understand the details, but...
If `rule` consumed *no* tokens, then all error labels
from `rule`'s result are overrided with the
given `l`. Otherwise, the old labels are
untouched, as they contain information from
further down the input.

Rule Summary
============
* Consumes: Whatever `rule` consumes.
* Description: FnParse Hound rule-maker
* Error: Smartly determines the appropriate error message.
* Product: `rule`'s product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/lex">lex</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (lex subrule)
</pre>
  <pre id="var-docstr">Creates a lexical rule.
You use this whenever you want the lexer to
*backtrack* when it fails, *even* if it consumes
tokens. (Don't forget, usually *if a rule consumes
tokens, it cannot backtrack at all*.)

How it works
============
Rules surrounded by lex count as 'empty' rules
rules that don't consume any tokensregardless
if they really consume tokens or not. This changes
the behavior of any summed rules that contain it.

Why you would need to use it
============================
  (require '[edu.arizona.fnparse.hound :as r])
  (def &lt;ws&gt; (r/lit \space))
  (def &lt;claim&gt; (r/phrase "x = 1"))
  (def &lt;let-expr&gt; (r/cat (r/phrase "let") &lt;ws&gt; &lt;let-expr&gt;))
  (def &lt;identifier&gt; (r/rep r/&lt;ascii-letter&gt;))
  (def &lt;expr&gt; (r/+ &lt;let-expr&gt; &lt;identifier&gt;))
  (parse &lt;let-expr&gt; "number" nil) ; Line one
  (parse &lt;let-expr&gt; "letter" nil) ; Line two

In the code above, line one will give a successful
parse, because the input "number" matches
&lt;indentifier&gt;.

But line two will give a failure. This is because
(r/phrase "let") will match, but the &lt;ws&gt; after it
will not match. Thus, &lt;let-expr&gt; fails. Also, because
&lt;let-expr&gt; consumed the first three tokens of "letter",
the summed rule &lt;expr&gt; will immediately fail without
even trying &lt;identifier-.

And so how you use it
=====================
Change &lt;let-expr&gt; to use the following:
  (r/cat (r/lex (r/phrase "let")) &lt;ws&gt; &lt;let-expr&gt;)
Now both line one and two will be successful.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/lit">lit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (lit token)
</pre>
  <pre id="var-docstr">Creates a rule of a literal. A shortcut for
`(term (partial = token))`. It automatically adds an
appropriate label.

Rule Summary
============
* Consumes: One token, equal to the given `token`.
* Description: FnParse Hound rule-maker
* Error: When `(lit \a) fails, its error says, "Expected 'a'."
* Product: Always the consumed `token`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/make-state">make-state</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (make-state input &amp; {:keys #{context alter-location location}, :or {location (c/make-standard-location 0 0), alter-location c/standard-alter-location}})
</pre>
  <pre id="var-docstr">Creates a state with the given parameters.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/mapcat">mapcat</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (mapcat f &amp; token-colls)
</pre>
  <pre id="var-docstr">Creates a rule that is the result of
applying `cat` to the result of applying map
to `f` and `token-colls`.
Use the `phrase` function instead of this
function when `f` is just `lit`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/mapsum">mapsum</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (mapsum f &amp; token-colls)
</pre>
  <pre id="var-docstr">Creates a rule that is the result of applying `+` to the
result of applying map to `f` and `token-colls`.
Use the `set-term` function instead of this
function when `f` is just `lit`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/match">match</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (match state rule &amp; {:keys #{failure-fn success-fn}, :or {success-fn print-success, failure-fn print-failure}})
</pre>
  <pre id="var-docstr">The general matching function of FnParse. Attempts to
match the given rule to at least the beginning of the given input.

*   `rule`: The rule to match with.
*   `state`: The initial state.
*   `success-fn`: An optional function called when the rule
    matches the input.
    `(complete-fn final-product final-remainder)` is called.
*   `failure-fn`: An optional function called when the rule does not
    match the input. `(failure-fn final-error)` is called,
    where `final-error` is an object of type
    `:edu.arizona.fnparse.ParseError`.
  
If `success-fn` and `failure-fn` aren't included, then
`match` will print out a report of the parsing result.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/not-followed">not-followed</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (not-followed l &lt;base&gt; &amp; following-rules)
</pre>
  <pre id="var-docstr">See also `except`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/nothing-descriptors">nothing-descriptors</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The error descriptors that `&lt;nothing&gt;` uses.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/opt">opt</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (opt rule)
</pre>
  <pre id="var-docstr">Creates an optional rule. It is equivalent to `(+ rule emptiness)`.

Rule Summary
============
* Consumes: Either whatever `rule` consumes (if it succeeds) or no tokens.
* Description: FnParse Hound rule-maker
* Product: Either `rule`'s product (if it succeeds) or `nil` if it fails.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/parser-m">parser-m</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">The monad that FnParse Hound uses.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/peek">peek</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (peek rule)
</pre>
  <pre id="var-docstr">Creates a lookahead rule. Checks if the given
`rule` succeeds, but doesn't actually consume
any tokens.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/phrase">phrase</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (phrase tokens)
</pre>
  <pre id="var-docstr">Creates a phrase rule, which succeeds
only when the next few tokens all
consecutively match the given tokens.
(Actually, it's just `(mapcat lit tokens)`.)</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/prefix">prefix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (prefix prefix-rule body-rule)
</pre>
  <pre id="var-docstr">Creates a prefixed rule. Use when you want to
concatenate two rules, but you don't care about
the first rule's product.
Its product is always the body-rule's product.
A shortcut for `(for [_ prefix-rule, content body-rule] content)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/prod">prod</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (prod product)
</pre>
  <pre id="var-docstr">Creates a rule that always returns the given `product`.

Use the `:let` modifier in preference to this function
when you use this inside rule comprehensions from the
`for` macro.

Is the result monadic function of the `parser-m` monad.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker
* Product: The given `product`.
* Success: Always.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/radix-digit">radix-digit</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (radix-digit core)
</pre>
  <pre id="var-docstr">Returns a rule that accepts one digit character
token in the number system with the given `core`.
For instance, `(radix-digit 12)` is a rule
of a single duodecimal digit.

Digits past 9 are case-insensitive letters:
11, for instance, is \b or \B. cores above
36 are accepted, but there's no way to use
digits beyond \Z (which corresponds to 36).

The rules `&lt;decimal-digit&gt;` and
`&lt;hexadecimal-digit&gt;` are already provided.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule-maker
* Product: The digit's corresponding integer.
* Success: If the next token is a digit
  character in the given `core`'s number
  system.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/radix-label">radix-label</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (radix-label core)
</pre>
  <pre id="var-docstr">The function used by radix-digit to smartly
create digit labels for the given `core`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/rep">rep</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (rep rule)
</pre>
  <pre id="var-docstr">Creates a one-or-more greedy repetition rule. Tries to
repeat consecutively the given `rule` as many
times as possible.

*Warning!* Do not use this with any rules that
possibly may succeed without consuming any tokens.
An error will be thrown, because it would otherwise
create an infinite loop.

Rule Summary
============
* Consumes: As many tokens as rule can consecutively consume.
* Description: FnParse Hound rule-maker
* Product: A *vector* of all of `rule`'s consecutive products.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/rep*">rep*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (rep* rule)
</pre>
  <pre id="var-docstr">Creates a zero-or-more greedy repetition rule.

*Warning!* Do not use this with any rules that
possibly may succeed without consuming any tokens.
An error will be thrown, because it would otherwise
create an infinite loop.

Rule Summary
============
* Consumes: As many tokens as rule can consecutively consume.
* Description: FnParse Hound rule-maker
* Product: A *vector* of all of `rule`'s consecutive products.
           If `rule` fails immediately, then this is `[]`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/rule?">rule?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (rule? obj)
</pre>
  <pre id="var-docstr">Tests if the given object is a Hound Rule, or a var containing a Hound Rule.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/separated-rep">separated-rep</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (separated-rep separator element)
</pre>
  <pre id="var-docstr">Creates a greedy repetition rule with a separator.
The `separator` is a rule that must succeed between
each `element` rule's success.

Rule Summary
============
* Description: FnParse Hound rule-maker
* Product: The vector of `element`'s successes.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/separated-rep*">separated-rep*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (separated-rep* separator element)
</pre>
  <pre id="var-docstr">Like `separated-rep`, but also calls `opt` afterwards.

Rule Summary
============
* Description: FnParse Hound rule-maker
* Product: A vector.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/set-term">set-term</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (set-term l tokens)
</pre>
  <pre id="var-docstr">Creates a terminal rule with a set.
A shortcut for `(term l (set tokens))`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/state?">state?</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (state? obj)
</pre>
  <pre id="var-docstr">Tests if the given object is a Hound State.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/substitute">substitute</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (substitute state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Substitutes all occurences of a rule in a sequence of tokens
with their respective products. Returns a lazy sequence of
tokens and products.

`flatten?` is a boolean. If it is true, then the substituting
products will be flattened into the input sequence; in that
case the products must always be Seqables.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/substitute-1">substitute-1</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (substitute-1 state rule &amp; {:keys #{flatten?}})
</pre>
  <pre id="var-docstr">Substitutes the first occurence of a rule in a sequence of
tokens with its respective product. Returns a lazy sequence
of tokens and products.

See `substitute`'s docs for information on `flatten?`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/suffix">suffix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (suffix body-rule suffix-rule)
</pre>
  <pre id="var-docstr">Creates a suffixed rule. Use when you want to
concatenate two rules, but you don't care about
the second rule's product.
Its product is always the body-rule's product.
A shortcut for `(for [content body-rule, _ suffix-rule] content)`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/template-sum">template-sum</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (template-sum argv expr &amp; values)
</pre>
  <pre id="var-docstr">Creates a summed rule using a template.
Acts very similarly to `clojure.template/do-template`,
but instead sums each rule together.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/term">term</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (term l predicate)
</pre>
  <pre id="var-docstr">Creates a terminal rule.

The new rule either consumes one token or fails.
It must have a `l` that describes it
and a `predicate` to test if the token it consumes is
valid.

Do you really need to use `term`?
=================================
* If you just want to make sure that the consumed
  token equals something, use `lit` instead.
* If you just want to make sure that the consumed
  token equals one of a bunch of things, use `term`
  on a set of tokens, or `set-term` on a sequence of
  tokens.
* If you want to use the complement of the predicate,
  use `antiterm`.
* If you don't care about what token is consumed,
  just as long as a token is consumed, use `-anything-`.
* If you want a terminal rule, but you want the result
  of the predicate to be the rule's product instead of
  the token itself, use `term*`. This is useful if
  you have a map of tokens and their products (e.g.
  string escape sequences).

Rule Summary
============
* Consumes: One token, any type that fulfills `pred`.
* Description: FnParse Hound rule-maker
* Error: When `(term "number" num?)` fails,
         its error is "Expected number."
* Product: The consumed token itself.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/term*">term*</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (term* l f)
</pre>
  <pre id="var-docstr">Exactly like `term`, only its product is the result of
`(f token)` rather than `token`.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/validate">validate</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (validate pred message rule)
</pre>
  <pre id="var-docstr">Creates a validating rule.

A convenience function. Returns a new rule that
acts like the given `rule`, but also validates
`rule`'s products with the given predicate.
Basically just a shortcut for `for` and `when`.

Rule Summary
============
* Consumes: What `rule` consumes.
* Description: FnParse Hound rule-maker
* Product: `rule`'s product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/vcat">vcat</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (vcat &amp; subrules)
</pre>
  <pre id="var-docstr">Exactly like cat, only applies `vec` to its product.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/when">when</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (when valid? message)
</pre>
  <pre id="var-docstr">Creates a maybe-failing rule
an either succeeding or a failing rule
depending on if `valid?` is logical true. If
`valid?`, then the rule always succeeds and acts
like `(prod valid?)`. If not `valid?`, then the
rule always fails and acts like `(with-error message)`.

Examples
========
This function is very useful for when you want
to validate a certain rule.

  (for [value &lt;number&gt;
        _ (when (&lt; odd 10)
            "number must be less than ten")]
      value)

The rule given above succeeds only when `&lt;number&gt;`
matches and `&lt;number&gt;`'s product is less than 10.

Rule Summary
============
* Consumes: No tokens.
* Description: FnParse Hound rule-maker
* Product: The value of `valid?`.
* Success: If `valid?` is a true value.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.hound/with-error">with-error</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (with-error message)
</pre>
  <pre id="var-docstr">Creates an always-failing rule with the given
message. Use this in preference to `&lt;nothing&gt;`.

Rule Summary
============
* Description: FnParse Hound rule-maker
* Error: An error with the given `message`.
* Success: Never.</pre>
  
</div>
<h2 id="namespace-name">edu.arizona.fnparse.json</h2>
<pre id="namespace-docstr">Contains a parser for [the JSON language][JSON], or
JavaScript Object Notation. It is a simple language for
storing simple data structures: numbers, strings,
"arrays" (i.e. vectors), and "objects" (i.e. maps).

The formal grammar can be seen in pictoral format
at [JSON's homepage][JSON] or in textual format in
[RFC 4627][RFC].

TODO: Implement numbers!

[JSON]: http://json.org
[RFC]: <a href="http://www.ietf.org/rfc/rfc4627">http://www.ietf.org/rfc/rfc4627</a></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;array-content&gt;">&lt;array-content&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a sequence of JSON values separated by commas, with optional
whitespace padding on the front.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A vector.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;array-end&gt;">&lt;array-end&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;array-start&gt;">&lt;array-start&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;array&gt;">&lt;array&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a JSON array. Optionally padded on the front with whitespace.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A vector.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;control-char&gt;">&lt;control-char&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes an ASCII control character, which is not allowed in strings.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;document&gt;">&lt;document&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a general JSON document, optionally padded
with whitespace on both sides.
The root rule of the JSON grammar.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;escape-char-start&gt;">&lt;escape-char-start&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;escaped-str-char&gt;">&lt;escaped-str-char&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes an escaped character in a string: a backslash
followed by an escape sequence.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A character.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;false&gt;">&lt;false&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;name-separator&gt;">&lt;name-separator&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;normal-str-char&gt;">&lt;normal-str-char&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes normal, non-espaced string character.
No control characters allowed.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A character.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;null&gt;">&lt;null&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;object-content&gt;">&lt;object-content&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a sequence of object entries separated by commas. Optionally
padded with whitepace on the front.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;object-end&gt;">&lt;object-end&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;object-entry&gt;">&lt;object-entry&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a string-value pair with a colon. They appear in objects.
Optionally padded on the front with whitespace.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A vector pair.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;object-start&gt;">&lt;object-start&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;object&gt;">&lt;object&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a JSON object. Optionally padded on the front with whitespace.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A map.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;str-char&gt;">&lt;str-char&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a general string character.

Rule Summary
============
* Consumes: One character.
* Description: FnParse Hound rule
* Product: A character or a sequence of characters.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;str-content&gt;">&lt;str-content&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a sequence of string characters.

Rule Summary
============
* Consumes: Zero or more characters.
* Description: FnParse Hound rule
* Product: A string.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;str-delimiter&gt;">&lt;str-delimiter&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;str&gt;">&lt;str&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a JSON string.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A string.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;true&gt;">&lt;true&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;unicode-sequence&gt;">&lt;unicode-sequence&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a lowercase 'u' followed by hexadecimal digits.

Rule Summary
============
* Description: FnParse Hound rule
* Product: The character with the given digits' Unicode code.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;value-separator&gt;">&lt;value-separator&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Padded on the front with optional whitespace.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;value&gt;">&lt;value&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes a general JSON value, optionally padded
with whitespace on the front.

Rule Summary
============
* Description: FnParse Hound rule
* Product: A vector, map, number, true, false, or nil.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.json/&lt;ws?&gt;">&lt;ws?&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">Consumes optional, ignored JSON whitespace.</pre>
  
</div>
<h2 id="namespace-name">edu.arizona.fnparse.math</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.math/&lt;addition-level&gt;">&lt;addition-level&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.math/&lt;multiplication-level&gt;">&lt;multiplication-level&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.math/&lt;number&gt;">&lt;number&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.math/&lt;parenthesized&gt;">&lt;parenthesized&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.math/&lt;symbol-content&gt;">&lt;symbol-content&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.math/&lt;ws&gt;">&lt;ws&gt;</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">No description available.</pre>
  
</div><div id="var-entry">
  <hr />
  <h2 id="edu.arizona.fnparse.math/ws-suffix">ws-suffix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (ws-suffix &lt;r&gt;)
</pre>
  <pre id="var-docstr">No description available.</pre>
  
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">No copyright info </div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>